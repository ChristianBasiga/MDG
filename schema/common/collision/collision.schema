package mdg_schema.common.collision;
import "common/metadata.schema";
import "improbable/standard_library.schema";
import "common/util.schema";

type CollisionPoint{
    EntityId colliding_with = 1;
    // Storing angle and magnitude from center of entity collided with.
    mdg_schema.common.util.Vector3f distance = 2;

    bool is_trigger = 3;
}

// Will add vision too later.
// Along with having event, will have state that is updated as well. Keeps acting upon collisions more flexible.
type CollisionEventPayload{
    map<EntityId, CollisionPoint> collided_with = 2;
}

// This is component that is essentially the event payload but as a maintained state.
component Collision{
    id = 861;
    map<EntityId, CollisionPoint> collisions = 1;
    map<EntityId, CollisionPoint> triggers = 2;
    // collisions update incrementing and decrementing but not
    // but if assigning clear map to dictionary it don't register pdate. 
    // so this is literally a dirty flag essentially.
    int32 collision_count = 3;
    int32 trigger_count = 4;
    event CollisionEventPayload trigger_happen;
    event CollisionEventPayload collision_happen;
}


